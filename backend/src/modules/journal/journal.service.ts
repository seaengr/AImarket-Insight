import fs from 'fs';
import path from 'path';
import { logger } from '../../shared/logger';
import { SignalType } from '../../types/api.types';

export interface SignalLog {
    id: string;
    timestamp: number;
    symbol: string;
    type: SignalType;
    price: number;
    confidence: number;
    outcome: 'WIN' | 'LOSS' | 'PENDING';
    verifiedAt?: number;
    actualPriceAtFullfillment?: number;
}

export class JournalService {
    private journalPath: string;
    private MAX_ENTRIES = 5000;

    constructor() {
        this.journalPath = path.join(process.cwd(), 'data', 'journal.json');
        this.ensureDir();
    }

    private ensureDir() {
        const dir = path.dirname(this.journalPath);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        if (!fs.existsSync(this.journalPath)) {
            fs.writeFileSync(this.journalPath, JSON.stringify([]));
        }
    }

    private readLogs(): SignalLog[] {
        try {
            const data = fs.readFileSync(this.journalPath, 'utf-8');
            return JSON.parse(data);
        } catch (error) {
            return [];
        }
    }

    private writeLogs(logs: SignalLog[]) {
        // Implement Rolling Log: Keep only last MAX_ENTRIES
        const rollingLogs = logs.slice(-this.MAX_ENTRIES);
        fs.writeFileSync(this.journalPath, JSON.stringify(rollingLogs, null, 2));
    }

    /**
     * Logs a new signal generated by the AI
     */
    async logSignal(symbol: string, type: SignalType, price: number, confidence: number): Promise<void> {
        if (type === 'HOLD') return;

        const logs = this.readLogs();
        const newLog: SignalLog = {
            id: Math.random().toString(36).substr(2, 9),
            timestamp: Date.now(),
            symbol,
            type,
            price,
            confidence,
            outcome: 'PENDING'
        };

        logs.push(newLog);
        this.writeLogs(logs);
        logger.info(`[Journal] Logged ${type} signal for ${symbol} @ ${price}`);
    }

    /**
     * Computes the win rate for a specific symbol
     */
    getStats(symbol: string): { winRate: number; totalTrades: number } {
        const logs = this.readLogs();
        const symbolLogs = logs.filter(l => l.symbol === symbol && l.outcome !== 'PENDING');

        if (symbolLogs.length === 0) return { winRate: 0, totalTrades: 0 };

        const wins = symbolLogs.filter(l => l.outcome === 'WIN').length;
        const winRate = (wins / symbolLogs.length) * 100;

        return {
            winRate: Math.round(winRate),
            totalTrades: symbolLogs.length
        };
    }

    /**
     * Returns pending signals that need verification
     */
    getPendingSignals(): SignalLog[] {
        return this.readLogs().filter(l => l.outcome === 'PENDING');
    }

    /**
     * Updates an existing log entry
     */
    updateLog(id: string, update: Partial<SignalLog>) {
        const logs = this.readLogs();
        const index = logs.findIndex(l => l.id === id);
        if (index !== -1) {
            logs[index] = { ...logs[index], ...update };
            this.writeLogs(logs);
        }
    }
    /**
     * Returns the full trade history
     */
    getHistory(limit: number = 50): SignalLog[] {
        return this.readLogs().slice(-limit).reverse();
    }

    /**
     * Get global statistics for all symbols
     */
    getAllStats(): { winRate: number; totalTrades: number; wins: number; losses: number } {
        const logs = this.readLogs().filter(l => l.outcome !== 'PENDING');

        if (logs.length === 0) return { winRate: 0, totalTrades: 0, wins: 0, losses: 0 };

        const wins = logs.filter(l => l.outcome === 'WIN').length;
        const losses = logs.filter(l => l.outcome === 'LOSS').length;
        const winRate = (wins / logs.length) * 100;

        return {
            winRate: Math.round(winRate),
            totalTrades: logs.length,
            wins,
            losses
        };
    }
}

export const journalService = new JournalService();
